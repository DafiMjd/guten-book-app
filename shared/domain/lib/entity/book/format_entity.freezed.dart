// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'format_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$FormatsEntity {

 String? get textHtml; String? get textHtmlCharsetUtf8; String? get applicationEpubZip; String? get applicationXMobipocketEbook; String? get textPlainCharsetUsAscii; String? get textPlainCharsetUtf8; String? get applicationRdfXml; String? get imageJpeg; String? get applicationOctetStream;
/// Create a copy of FormatsEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FormatsEntityCopyWith<FormatsEntity> get copyWith => _$FormatsEntityCopyWithImpl<FormatsEntity>(this as FormatsEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FormatsEntity&&(identical(other.textHtml, textHtml) || other.textHtml == textHtml)&&(identical(other.textHtmlCharsetUtf8, textHtmlCharsetUtf8) || other.textHtmlCharsetUtf8 == textHtmlCharsetUtf8)&&(identical(other.applicationEpubZip, applicationEpubZip) || other.applicationEpubZip == applicationEpubZip)&&(identical(other.applicationXMobipocketEbook, applicationXMobipocketEbook) || other.applicationXMobipocketEbook == applicationXMobipocketEbook)&&(identical(other.textPlainCharsetUsAscii, textPlainCharsetUsAscii) || other.textPlainCharsetUsAscii == textPlainCharsetUsAscii)&&(identical(other.textPlainCharsetUtf8, textPlainCharsetUtf8) || other.textPlainCharsetUtf8 == textPlainCharsetUtf8)&&(identical(other.applicationRdfXml, applicationRdfXml) || other.applicationRdfXml == applicationRdfXml)&&(identical(other.imageJpeg, imageJpeg) || other.imageJpeg == imageJpeg)&&(identical(other.applicationOctetStream, applicationOctetStream) || other.applicationOctetStream == applicationOctetStream));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textHtml,textHtmlCharsetUtf8,applicationEpubZip,applicationXMobipocketEbook,textPlainCharsetUsAscii,textPlainCharsetUtf8,applicationRdfXml,imageJpeg,applicationOctetStream);

@override
String toString() {
  return 'FormatsEntity(textHtml: $textHtml, textHtmlCharsetUtf8: $textHtmlCharsetUtf8, applicationEpubZip: $applicationEpubZip, applicationXMobipocketEbook: $applicationXMobipocketEbook, textPlainCharsetUsAscii: $textPlainCharsetUsAscii, textPlainCharsetUtf8: $textPlainCharsetUtf8, applicationRdfXml: $applicationRdfXml, imageJpeg: $imageJpeg, applicationOctetStream: $applicationOctetStream)';
}


}

/// @nodoc
abstract mixin class $FormatsEntityCopyWith<$Res>  {
  factory $FormatsEntityCopyWith(FormatsEntity value, $Res Function(FormatsEntity) _then) = _$FormatsEntityCopyWithImpl;
@useResult
$Res call({
 String? textHtml, String? textHtmlCharsetUtf8, String? applicationEpubZip, String? applicationXMobipocketEbook, String? textPlainCharsetUsAscii, String? textPlainCharsetUtf8, String? applicationRdfXml, String? imageJpeg, String? applicationOctetStream
});




}
/// @nodoc
class _$FormatsEntityCopyWithImpl<$Res>
    implements $FormatsEntityCopyWith<$Res> {
  _$FormatsEntityCopyWithImpl(this._self, this._then);

  final FormatsEntity _self;
  final $Res Function(FormatsEntity) _then;

/// Create a copy of FormatsEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textHtml = freezed,Object? textHtmlCharsetUtf8 = freezed,Object? applicationEpubZip = freezed,Object? applicationXMobipocketEbook = freezed,Object? textPlainCharsetUsAscii = freezed,Object? textPlainCharsetUtf8 = freezed,Object? applicationRdfXml = freezed,Object? imageJpeg = freezed,Object? applicationOctetStream = freezed,}) {
  return _then(FormatsEntity(
textHtml: freezed == textHtml ? _self.textHtml : textHtml // ignore: cast_nullable_to_non_nullable
as String?,textHtmlCharsetUtf8: freezed == textHtmlCharsetUtf8 ? _self.textHtmlCharsetUtf8 : textHtmlCharsetUtf8 // ignore: cast_nullable_to_non_nullable
as String?,applicationEpubZip: freezed == applicationEpubZip ? _self.applicationEpubZip : applicationEpubZip // ignore: cast_nullable_to_non_nullable
as String?,applicationXMobipocketEbook: freezed == applicationXMobipocketEbook ? _self.applicationXMobipocketEbook : applicationXMobipocketEbook // ignore: cast_nullable_to_non_nullable
as String?,textPlainCharsetUsAscii: freezed == textPlainCharsetUsAscii ? _self.textPlainCharsetUsAscii : textPlainCharsetUsAscii // ignore: cast_nullable_to_non_nullable
as String?,textPlainCharsetUtf8: freezed == textPlainCharsetUtf8 ? _self.textPlainCharsetUtf8 : textPlainCharsetUtf8 // ignore: cast_nullable_to_non_nullable
as String?,applicationRdfXml: freezed == applicationRdfXml ? _self.applicationRdfXml : applicationRdfXml // ignore: cast_nullable_to_non_nullable
as String?,imageJpeg: freezed == imageJpeg ? _self.imageJpeg : imageJpeg // ignore: cast_nullable_to_non_nullable
as String?,applicationOctetStream: freezed == applicationOctetStream ? _self.applicationOctetStream : applicationOctetStream // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}


// dart format on
